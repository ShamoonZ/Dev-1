<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Video Player</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { height: 100vh; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        .video-container { position: relative; width: 100vw; height: 100vh; }

        /* Two stacked videos for smooth switching */
        video.video-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            object-fit: cover;
            background: #000;
            will-change: opacity;
        }

        /* buffer (background) is under main (visible) */
        #mainVideo { z-index: 5; opacity: 1; }
        #bufferVideo { z-index: 4; opacity: 0; pointer-events: none; }

        .controls {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 10;
            display: grid; grid-template-rows: 1fr 1fr;
        }
        .control-top { grid-row: 1; display: flex; width: 100%; }
        .control-bottom { grid-row: 2; display: flex; width: 100%; }

        .control-btn {
            background: transparent; border: none; cursor: pointer; touch-action: manipulation;
            user-select: none; -webkit-tap-highlight-color: transparent; flex: 1; position: relative; overflow: hidden;
            outline: none; box-shadow: none;
        }
        .control-btn:active, .control-btn:focus, .control-btn:hover { background: transparent !important; outline: none !important; box-shadow: none !important; }

        /* Keep accessible names but hide visually */
        .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }

        #loadingScreen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #fff; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
        }
        #loadingScreen.hidden { display: none; }
        .loader {
            width: 50px; height: 50px; border: 5px solid #e0e0e0; border-top: 5px solid #2196F3;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loader"></div>
    </div>

    <div class="video-container">
        <!-- mainVideo shows the current visible frame. bufferVideo preloads the next clip underneath. -->
        <video id="mainVideo" class="video-layer" muted playsinline preload="auto" webkit-playsinline></video>
        <video id="bufferVideo" class="video-layer" muted playsinline preload="auto" webkit-playsinline></video>

        <div class="controls">
            <div class="control-top">
                <button class="control-btn" id="smileBtn" aria-label="smile"></button>
            </div>
            <div class="control-bottom">
                <button class="control-btn" id="leftBtn" aria-label="left"></button>
                <button class="control-btn" id="rightBtn" aria-label="right"></button>
            </div>
        </div>
    </div>

    <script>
        // Elements
        let mainEl = document.getElementById('mainVideo');
        let bufferEl = document.getElementById('bufferVideo');
        const smileBtn = document.getElementById('smileBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        // Video paths
        const videos = { smile: 'smile.mp4', left: 'left.mp4', right: 'right.mp4' };

        // Keep track of currently visible type
        let currentVideoType = null;
        let loading = false; // prevent double loads

        // Ensure both videos follow same muted state
        function syncMuted() {
            bufferEl.muted = mainEl.muted;
        }

        // Freeze a video on its last frame (useful when paused)
        function freezeAtLastFrame(v) {
            try {
                if (v.duration && isFinite(v.duration) && v.duration > 0) {
                    v.currentTime = Math.max(0, v.duration - 0.1);
                    v.pause();
                } else {
                    v.pause();
                }
            } catch (e) {
                // some browsers may throw when seeking near end; fallback to pause
                v.pause();
            }
        }

        // Smoothly switch to a new video: preload in bufferEl, keep mainEl visible until buffer is ready
        function playVideoSmooth(videoType) {
            if (loading) return; // simple debounce

            // If the requested type is already the currently-visible one,
            // restart it immediately instead of doing a buffer swap.
            if (videoType === currentVideoType) {
                try {
                    // restart from beginning and play (both videos are muted so autoplay should work)
                    mainEl.currentTime = 0;
                    const p = mainEl.play();
                    if (p !== undefined) {
                        p.catch(err => {
                            console.warn('Play attempt failed when restarting same video:', err);
                        });
                    }
                } catch (e) {
                    console.warn('Error while restarting the same video:', e);
                }
                return;
            }

            syncMuted();
            loading = true;

            // keep the currently visible mainEl as-is so its last frame remains visible
            // load new source into bufferEl (the hidden layer)
            bufferEl.src = videos[videoType];
            bufferEl.load();

            // Safety: if canplaythrough doesn't fire within X ms, give up and keep main frame
            const timeout = setTimeout(() => {
                bufferEl.removeEventListener('canplaythrough', onCanPlay);
                bufferEl.removeEventListener('error', onError);
                console.warn('Buffer load timeout — keeping current frame');
                loading = false;
            }, 8000);

            // If buffer is already the same src and ready, skip waiting
            const onCanPlay = function () {
                clearTimeout(timeout);
                bufferEl.removeEventListener('canplaythrough', onCanPlay);
                bufferEl.removeEventListener('error', onError);

                // try to play buffer silently (must be muted for autoplay to work reliably)
                const playPromise = bufferEl.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // wait for first frame to render before switching
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                // crossfade quickly: show buffer, hide main
                                bufferEl.style.opacity = '1';
                                mainEl.style.opacity = '0';

                                // pause and freeze the old main (so its last frame is preserved if needed later)
                                freezeAtLastFrame(mainEl);

                                // swap references so the new visible element becomes mainEl
                                const oldMain = mainEl;
                                mainEl = bufferEl;
                                bufferEl = oldMain;

                                // ensure the now-buffer (old main) is hidden under the new main
                                bufferEl.style.opacity = '0';

                                currentVideoType = videoType;
                                loading = false;
                            });
                        });
                    }).catch(err => {
                        console.warn('Autoplay prevented or playback error on buffer:', err);
                        // If playback failed, keep showing the last frame of mainEl and don't swap
                        loading = false;
                    });
                } else {
                    // older browsers: assume play succeeded
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            bufferEl.style.opacity = '1';
                            mainEl.style.opacity = '0';
                            freezeAtLastFrame(mainEl);
                            const oldMain = mainEl;
                            mainEl = bufferEl;
                            bufferEl = oldMain;
                            bufferEl.style.opacity = '0';
                            currentVideoType = videoType;
                            loading = false;
                        });
                    });
                }
            };

            const onError = function (e) {
                clearTimeout(timeout);
                bufferEl.removeEventListener('canplaythrough', onCanPlay);
                bufferEl.removeEventListener('error', onError);
                console.error('Error loading buffer video', e);
                // loading failed — keep showing mainEl's frame
                loading = false;
            };

            bufferEl.addEventListener('canplaythrough', onCanPlay);
            bufferEl.addEventListener('error', onError);
        }

        // Freeze visible video on ended
        function onEndedHandler(e) {
            freezeAtLastFrame(e.target);
        }

        mainEl.addEventListener('ended', onEndedHandler);
        bufferEl.addEventListener('ended', onEndedHandler);

        // Button wiring
        function addButtonListener(button, videoType) {
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                playVideoSmooth(videoType);
            };
            button.addEventListener('click', handler);
            button.addEventListener('touchend', handler);
        }

        addButtonListener(smileBtn, 'smile');
        addButtonListener(leftBtn, 'left');
        addButtonListener(rightBtn, 'right');

        // Prevent gestures that might interfere
        videoPreventInteractions();

        function videoPreventInteractions() {
            mainEl.addEventListener('touchstart', (e) => e.preventDefault());
            bufferEl.addEventListener('touchstart', (e) => e.preventDefault());

            mainEl.addEventListener('click', (e) => e.preventDefault());
            bufferEl.addEventListener('click', (e) => e.preventDefault());

            document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            document.addEventListener('gesturestart', (e) => e.preventDefault());

            // Prevent double-tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) { event.preventDefault(); }
                lastTouchEnd = now;
            }, false);
        }

        // Initial adjust
        function adjustVideoSize() {
            const main = document.getElementById('mainVideo');
            const buffer = document.getElementById('bufferVideo');
            main.style.width = buffer.style.width = '100vw';
            main.style.height = buffer.style.height = '100vh';
        }
        window.addEventListener('orientationchange', () => setTimeout(adjustVideoSize, 100));
        window.addEventListener('resize', adjustVideoSize);
        window.addEventListener('load', () => { adjustVideoSize(); setTimeout(adjustVideoSize, 500); });
        document.addEventListener('visibilitychange', () => { if (!document.hidden) setTimeout(adjustVideoSize, 100); });

        // Start with a default video (optional) to have a frame visible — you can remove or change this
        // If you want nothing initially, comment the next line.
        // playVideoSmooth('smile');

        // Preload all videos before hiding loading screen
        (function preloadVideos() {
            const loadingScreen = document.getElementById('loadingScreen');
            const videoSources = Object.values(videos);
            let loadedCount = 0;

            function checkAllLoaded() {
                loadedCount++;
                if (loadedCount === videoSources.length) {
                    loadingScreen.classList.add('hidden');
                }
            }

            videoSources.forEach(src => {
                const video = document.createElement('video');
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';
                video.src = src;
                video.addEventListener('canplaythrough', checkAllLoaded);
                video.addEventListener('error', checkAllLoaded);
                video.load();
            });
        })();
    </script>
</body>
</html>
